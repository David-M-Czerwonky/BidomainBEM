/*
 * Auto-generated by stringify
 */

const char* mex_header =
  "/* Code generated by mwrap 1.1 */\n"
  "/*\n"
  "  Copyright statement for mwrap:\n"
  "\n"
  "  mwrap -- MEX file generation for MATLAB and Octave\n"
  "  Copyright (c) 2007-2008 David Bindel\n"
  "\n"
  "  Permission is hereby granted, free of charge, to any person obtaining a copy\n"
  "  of this software and associated documentation files (the \"Software\"), to deal\n"
  "  in the Software without restriction, including without limitation the rights\n"
  "  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n"
  "  copies of the Software, and to permit persons to whom the Software is\n"
  "  furnished to do so, subject to the following conditions:\n"
  "\n"
  "  The above copyright notice and this permission notice shall be included in\n"
  "  all copies or substantial portions of the Software.\n"
  "\n"
  "  You may distribute a work that contains part or all of the source code\n"
  "  generated by mwrap under the terms of your choice.\n"
  "\n"
  "  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n"
  "  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n"
  "  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n"
  "  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n"
  "  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n"
  "  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n"
  "  THE SOFTWARE.\n"
  "*/\n"
  "\n"
  "#include <stdio.h>\n"
  "#include <string.h>\n"
  "#include <stddef.h>\n"
  "\n"
  "#include <mex.h>\n"
  "\n"
  "#if MX_HAS_INTERLEAVED_COMPLEX\n"
  "#include <matrix.h>\n"
  "#endif\n"
  "\n"
  "\n"
  "/*\n"
  " * Records for call profile.\n"
  " */\n"
  "int* mexprofrecord_= NULL;\n"
  "\n"
  "\n"
  "/*\n"
  " * Support routines for copying data into and out of the MEX stubs, R2018a\n"
  " */\n"
  "\n"
  "#if MX_HAS_INTERLEAVED_COMPLEX\n"
  "\n"
  "void* mxWrapGetP(const mxArray* a, const char* fmt, const char** e)\n"
  "{\n"
  "    void* p = NULL;\n"
  "#ifdef R2008OO\n"
  "    mxArray* ap;\n"
  "#endif\n"
  "    if (mxGetClassID(a) == mxDOUBLE_CLASS && mxIsComplex(a) )\n"
  "    {\n"
  "        if( mxGetM(a)*mxGetN(a) == 1 && (*mxGetComplexDoubles(a)).real == 0 )\n"
  "        return NULL;\n"
  "    }\n"
  "    if (mxGetClassID(a) == mxDOUBLE_CLASS && !mxIsComplex(a) )\n"
  "    {\n"
  "        if( mxGetM(a)*mxGetN(a) == 1 && *mxGetDoubles(a) == 0)\n"
  "        return NULL;\n"
  "    }\n"
  "    if (mxIsChar(a)) {\n"
  "        char pbuf[128];\n"
  "        mxGetString(a, pbuf, sizeof(pbuf));\n"
  "        sscanf(pbuf, fmt, &p);\n"
  "    } \n"
  "#ifdef R2008OO\n"
  "    else if (ap = mxGetProperty(a, 0, \"mwptr\")) {\n"
  "        return mxWrapGetP(ap, fmt, e);\n"
  "    }\n"
  "#endif\n"
  "    if (p == 0)\n"
  "        *e = \"Invalid pointer\";\n"
  "    return p;\n"
  "}\n"
  "\n"
  "mxArray* mxWrapCreateP(void* p, const char* fmt)\n"
  "{\n"
  "    if (p == 0) {\n"
  "        mxArray* z = mxCreateDoubleMatrix(1,1, mxREAL);\n"
  "        *mxGetDoubles(z) = 0;\n"
  "        return z;\n"
  "    } else {\n"
  "        char pbuf[128];\n"
  "        sprintf(pbuf, fmt, p);\n"
  "        return mxCreateString(pbuf);\n"
  "    }\n"
  "}\n"
  "\n"
  "mxArray* mxWrapStrncpy(const char* s)\n"
  "{\n"
  "    if (s) {\n"
  "        return mxCreateString(s);\n"
  "    } else {\n"
  "        mxArray* z = mxCreateDoubleMatrix(1,1, mxREAL);\n"
  "        *mxGetDoubles(z) = 0;\n"
  "        return z;\n"
  "    }\n"
  "}\n"
  "\n"
  "char* mxWrapGetString(const mxArray* a, const char** e)\n"
  "{\n"
  "    char* s;\n"
  "    mwSize slen;\n"
  "    if (!a || (!mxIsChar(a) && mxGetM(a)*mxGetN(a) > 0)) {\n"
  "        *e = \"Invalid string argument\";\n"
  "        return NULL;\n"
  "    }\n"
  "    slen = mxGetM(a)*mxGetN(a) + 1;\n"
  "    s = (char*) mxMalloc(slen);\n"
  "    if (mxGetM(a)*mxGetN(a) == 0)\n"
  "        *s = 0;\n"
  "    else\n"
  "        mxGetString(a, s, slen);\n"
  "    return s;\n"
  "}\n"
  "\n"
  "\n"
  "double mxWrapGetScalar(const mxArray* a, const char** e)\n"
  "{\n"
  "    if (!a || mxGetClassID(a) != mxDOUBLE_CLASS || mxGetM(a)*mxGetN(a) != 1) {\n"
  "        *e = \"Invalid scalar argument\";\n"
  "        return 0;\n"
  "    }\n"
  "    if( mxIsComplex(a) )\n"
  "      return (double) (*mxGetComplexDoubles(a)).real;\n"
  "    else\n"
  "      return (double) (*mxGetDoubles(a));\n"
  "}\n"
  "\n"
  "#define mxWrapGetArrayDef(func, T) \\\n"
  "T* func(const mxArray* a, const char** e)     \\\n"
  "{ \\\n"
  "    T* array; \\\n"
  "    mwSize arraylen; \\\n"
  "    mwIndex i; \\\n"
  "    T* p; \\\n"
  "    double* q; \\\n"
  "    mxComplexDouble* z; \\\n"
  "    if (!a || mxGetClassID(a) != mxDOUBLE_CLASS) { \\\n"
  "        *e = \"Invalid array argument, mxDOUBLE_CLASS expected\"; \\\n"
  "        return 0; \\\n"
  "    } \\\n"
  "    arraylen = mxGetM(a)*mxGetN(a); \\\n"
  "    array = (T*) mxMalloc(mxGetM(a)*mxGetN(a) * sizeof(T)); \\\n"
  "    p = array; \\\n"
  "    if( mxIsComplex(a) ) \\\n"
  "      { \\\n"
  "	z = mxGetComplexDoubles(a);	   \\\n"
  "	for (i = 0; i < arraylen; ++i)		\\\n"
  "	  *p++ = (T) (*z++).real;			\\\n"
  "      } \\\n"
  "    else \\\n"
  "      {				   \\\n"
  "	q = mxGetDoubles(a);	   \\\n"
  "	for (i = 0; i < arraylen; ++i)		\\\n"
  "	  *p++ = (T) (*q++);			\\\n"
  "      } \\\n"
  "    return array; \\\n"
  "}\n"
  "\n"
  "\n"
  "#define mxWrapCopyDef(func, T) \\\n"
  "void func(mxArray* a, const T* q, mwSize n) \\\n"
  "{ \\\n"
  "    mwIndex i; \\\n"
  "    double* p;	\\\n"
  "    mxComplexDouble* z; \\\n"
  "    if( mxIsComplex(a) ) \\\n"
  "      { \\\n"
  "	z = mxGetComplexDoubles(a);	   \\\n"
  "	for (i = 0; i < n; ++i)		\\\n"
  "	  (*z++).real = (double) *q++;	\\\n"
  "	  (*z++).imag = 0;	\\\n"
  "      } \\\n"
  "    else \\\n"
  "      {				   \\\n"
  "	p = mxGetDoubles(a);	   \\\n"
  "	for (i = 0; i < n; ++i)		\\\n"
  "	  *p++ = (double) *q++;		\\\n"
  "      } \\\n"
  "}\n"
  "\n"
  "\n"
  "#define mxWrapReturnDef(func, T) \\\n"
  "mxArray* func(const T* q, mwSize m, mwSize n) \\\n"
  "{ \\\n"
  "    mwIndex i; \\\n"
  "    double* p; \\\n"
  "    if (!q) { \\\n"
  "        return mxCreateDoubleMatrix(0,0, mxREAL); \\\n"
  "    } else { \\\n"
  "        mxArray* a = mxCreateDoubleMatrix(m,n, mxREAL); \\\n"
  "        p = mxGetDoubles(a); \\\n"
  "        for (i = 0; i < m*n; ++i) \\\n"
  "	  *p++ = (double) *q++;	  \\\n"
  "        return a; \\\n"
  "    } \\\n"
  "}\n"
  "\n"
  "\n"
  "#define mxWrapGetScalarZDef(func, T, ZT, setz)	\\\n"
  "void func(T* z, const mxArray* a) \\\n"
  "{ \\\n"
  "    if( mxIsComplex(a) ) \\\n"
  "      { \\\n"
  "  setz(z, (ZT) (*mxGetComplexDoubles(a)).real, (ZT) (*mxGetComplexDoubles(a)).imag); \\\n"
  "      } \\\n"
  "    else \\\n"
  "      {				   \\\n"
  "  setz(z, (ZT) (*mxGetComplexDoubles(a)).real, (ZT) 0);	\\\n"
  "      } \\\n"
  "}\n"
  "\n"
  "\n"
  "#define mxWrapGetArrayZDef(func, T, ZT, setz)      \\\n"
  "T* func(const mxArray* a, const char** e)     \\\n"
  "{ \\\n"
  "    T* array; \\\n"
  "    mwSize arraylen; \\\n"
  "    mwIndex i; \\\n"
  "    T* p; \\\n"
  "    double* q; \\\n"
  "    mxComplexDouble* z; \\\n"
  "    if (!a || mxGetClassID(a) != mxDOUBLE_CLASS) { \\\n"
  "        *e = \"Invalid array argument, mxDOUBLE_CLASS expected\"; \\\n"
  "        return 0; \\\n"
  "    } \\\n"
  "    arraylen = mxGetM(a)*mxGetN(a); \\\n"
  "    array = (T*) mxMalloc(mxGetM(a)*mxGetN(a) * sizeof(T)); \\\n"
  "    p = array; \\\n"
  "    if( mxIsComplex(a) ) \\\n"
  "      { \\\n"
  "	z = mxGetComplexDoubles(a);	   \\\n"
  "	for (i = 0; i < arraylen; ++i) {	\\\n"
  "	  setz(p, (ZT) (*z).real, (ZT) (*z).imag);	\\\n"
  "  	  ++p; ++z; }					\\\n"
  "      } \\\n"
  "    else \\\n"
  "      {				   \\\n"
  "	q = mxGetDoubles(a);	   \\\n"
  "	for (i = 0; i < arraylen; ++i)	{	\\\n"
  "	  setz(p, (ZT) (*q), (ZT) 0 );		\\\n"
  "          ++p; ++q; }			\\\n"
  "      }						\\\n"
  "    return array; \\\n"
  "}\n"
  "\n"
  "\n"
  "#define mxWrapCopyZDef(func, T, freal, fimag)	    \\\n"
  "void func(mxArray* a, const T* q, mwSize n) \\\n"
  "{ \\\n"
  "    mwIndex i; \\\n"
  "    double* p;	\\\n"
  "    mxComplexDouble* z; \\\n"
  "    if( mxIsComplex(a) ) \\\n"
  "      { \\\n"
  "	z = mxGetComplexDoubles(a);	   \\\n"
  "	for (i = 0; i < n; ++i)	{		\\\n"
  "          (*z).real = freal(*q);			\\\n"
  "	  (*z).imag = fimag(*q);			\\\n"
  "	  ++z; ++q; 	}			\\\n"
  "      } \\\n"
  "    else \\\n"
  "      {				   \\\n"
  "	p = mxGetDoubles(a);	   \\\n"
  "	for (i = 0; i < n; ++i)		\\\n"
  "	  *p++ = freal(*q++);		\\\n"
  "      } \\\n"
  "}\n"
  "\n"
  "\n"
  "#define mxWrapReturnZDef(func, T, freal, fimag)	      \\\n"
  "mxArray* func(const T* q, mwSize m, mwSize n) \\\n"
  "{ \\\n"
  "    mwIndex i; \\\n"
  "    mxComplexDouble* p; \\\n"
  "    if (!q) { \\\n"
  "        return mxCreateDoubleMatrix(0,0, mxCOMPLEX); \\\n"
  "    } else { \\\n"
  "        mxArray* a = mxCreateDoubleMatrix(m,n, mxCOMPLEX); \\\n"
  "        p = mxGetComplexDoubles(a); \\\n"
  "        for (i = 0; i < m*n; ++i) {	  \\\n"
  "          (*p).real = freal(*q);			\\\n"
  "	  (*p).imag = fimag(*q);			\\\n"
  "	  ++p; ++q; 	}			\\\n"
  "        return a; \\\n"
  "    } \\\n"
  "}\n"
  "\n"
  "\n"
  "\n"
  "\n"
  "\n"
  "\n"
  "void* mxWrapGetP_single(const mxArray* a, const char* fmt, const char** e)\n"
  "{\n"
  "    void* p = NULL;\n"
  "#ifdef R2008OO\n"
  "    mxArray* ap;\n"
  "#endif\n"
  "    if (mxGetClassID(a) == mxSINGLE_CLASS && mxIsComplex(a) )\n"
  "    {\n"
  "        if( mxGetM(a)*mxGetN(a) == 1 && (*mxGetComplexSingles(a)).real == 0 )\n"
  "        return NULL;\n"
  "    }\n"
  "    if (mxGetClassID(a) == mxSINGLE_CLASS && !mxIsComplex(a) )\n"
  "    {\n"
  "        if( mxGetM(a)*mxGetN(a) == 1 && *mxGetSingles(a) == 0)\n"
  "        return NULL;\n"
  "    }\n"
  "    if (mxIsChar(a)) {\n"
  "        char pbuf[128];\n"
  "        mxGetString(a, pbuf, sizeof(pbuf));\n"
  "        sscanf(pbuf, fmt, &p);\n"
  "    } \n"
  "#ifdef R2008OO\n"
  "    else if (ap = mxGetProperty(a, 0, \"mwptr\")) {\n"
  "        return mxWrapGetP(ap, fmt, e);\n"
  "    }\n"
  "#endif\n"
  "    if (p == 0)\n"
  "        *e = \"Invalid pointer\";\n"
  "    return p;\n"
  "}\n"
  "\n"
  "mxArray* mxWrapCreateP_single(void* p, const char* fmt)\n"
  "{\n"
  "    if (p == 0) {\n"
  "        mxArray* z = mxCreateNumericMatrix(1,1, mxSINGLE_CLASS, mxREAL);\n"
  "        *mxGetSingles(z) = 0;\n"
  "        return z;\n"
  "    } else {\n"
  "        char pbuf[128];\n"
  "        sprintf(pbuf, fmt, p);\n"
  "        return mxCreateString(pbuf);\n"
  "    }\n"
  "}\n"
  "\n"
  "mxArray* mxWrapStrncpy_single(const char* s)\n"
  "{\n"
  "    if (s) {\n"
  "        return mxCreateString(s);\n"
  "    } else {\n"
  "        mxArray* z = mxCreateNumericMatrix(1,1, mxSINGLE_CLASS, mxREAL);\n"
  "        *mxGetSingles(z) = 0;\n"
  "        return z;\n"
  "    }\n"
  "}\n"
  "\n"
  "char* mxWrapGetString_single(const mxArray* a, const char** e)\n"
  "{\n"
  "    char* s;\n"
  "    mwSize slen;\n"
  "    if (!a || (!mxIsChar(a) && mxGetM(a)*mxGetN(a) > 0)) {\n"
  "        *e = \"Invalid string argument\";\n"
  "        return NULL;\n"
  "    }\n"
  "    slen = mxGetM(a)*mxGetN(a) + 1;\n"
  "    s = (char*) mxMalloc(slen);\n"
  "    if (mxGetM(a)*mxGetN(a) == 0)\n"
  "        *s = 0;\n"
  "    else\n"
  "        mxGetString(a, s, slen);\n"
  "    return s;\n"
  "}\n"
  "\n"
  "\n"
  "float mxWrapGetScalar_single(const mxArray* a, const char** e)\n"
  "{\n"
  "    if (!a || mxGetClassID(a) != mxSINGLE_CLASS || mxGetM(a)*mxGetN(a) != 1) {\n"
  "        *e = \"Invalid scalar argument\";\n"
  "        return 0;\n"
  "    }\n"
  "    if( mxIsComplex(a) )\n"
  "      return (float) (*mxGetComplexSingles(a)).real;\n"
  "    else\n"
  "      return (float) (*mxGetSingles(a));\n"
  "}\n"
  "\n"
  "#define mxWrapGetArrayDef_single(func, T) \\\n"
  "T* func(const mxArray* a, const char** e)     \\\n"
  "{ \\\n"
  "    T* array; \\\n"
  "    mwSize arraylen; \\\n"
  "    mwIndex i; \\\n"
  "    T* p; \\\n"
  "    float* q; \\\n"
  "    mxComplexSingle* z; \\\n"
  "    if (!a || mxGetClassID(a) != mxSINGLE_CLASS) { \\\n"
  "        *e = \"Invalid array argument, mxSINGLE_CLASS expected\"; \\\n"
  "        return 0; \\\n"
  "    } \\\n"
  "    arraylen = mxGetM(a)*mxGetN(a); \\\n"
  "    array = (T*) mxMalloc(mxGetM(a)*mxGetN(a) * sizeof(T)); \\\n"
  "    p = array; \\\n"
  "    if( mxIsComplex(a) ) \\\n"
  "      { \\\n"
  "	z = mxGetComplexSingles(a);	   \\\n"
  "	for (i = 0; i < arraylen; ++i)		\\\n"
  "	  *p++ = (T) (*z++).real;			\\\n"
  "      } \\\n"
  "    else \\\n"
  "      {				   \\\n"
  "	q = mxGetSingles(a);	   \\\n"
  "	for (i = 0; i < arraylen; ++i)		\\\n"
  "	  *p++ = (T) (*q++);			\\\n"
  "      } \\\n"
  "    return array; \\\n"
  "}\n"
  "\n"
  "\n"
  "#define mxWrapCopyDef_single(func, T) \\\n"
  "void func(mxArray* a, const T* q, mwSize n) \\\n"
  "{ \\\n"
  "    mwIndex i; \\\n"
  "    float* p;	\\\n"
  "    mxComplexSingle* z; \\\n"
  "    if( mxIsComplex(a) ) \\\n"
  "      { \\\n"
  "	z = mxGetComplexSingles(a);	   \\\n"
  "	for (i = 0; i < n; ++i)		\\\n"
  "	  (*z++).real = (float) *q++;	\\\n"
  "	  (*z++).imag = 0;	\\\n"
  "      } \\\n"
  "    else \\\n"
  "      {				   \\\n"
  "	p = mxGetSingles(a);	   \\\n"
  "	for (i = 0; i < n; ++i)		\\\n"
  "	  *p++ = (float) *q++;		\\\n"
  "      } \\\n"
  "}\n"
  "\n"
  "\n"
  "#define mxWrapReturnDef_single(func, T) \\\n"
  "mxArray* func(const T* q, mwSize m, mwSize n) \\\n"
  "{ \\\n"
  "    mwIndex i; \\\n"
  "    float* p; \\\n"
  "    if (!q) { \\\n"
  "        return mxCreateNumericMatrix(0,0, mxSINGLE_CLASS, mxREAL); \\\n"
  "    } else { \\\n"
  "        mxArray* a = mxCreateNumericMatrix(m,n, mxSINGLE_CLASS, mxREAL); \\\n"
  "        p = mxGetSingles(a); \\\n"
  "        for (i = 0; i < m*n; ++i) \\\n"
  "	  *p++ = (float) *q++;	  \\\n"
  "        return a; \\\n"
  "    } \\\n"
  "}\n"
  "\n"
  "\n"
  "#define mxWrapGetScalarZDef_single(func, T, ZT, setz)	\\\n"
  "void func(T* z, const mxArray* a) \\\n"
  "{ \\\n"
  "    if( mxIsComplex(a) ) \\\n"
  "      { \\\n"
  "  setz(z, (ZT) (*mxGetComplexSingles(a)).real, (ZT) (*mxGetComplexSingles(a)).imag); \\\n"
  "      } \\\n"
  "    else \\\n"
  "      {				   \\\n"
  "  setz(z, (ZT) (*mxGetComplexSingles(a)).real, (ZT) 0);	\\\n"
  "      } \\\n"
  "}\n"
  "\n"
  "\n"
  "#define mxWrapGetArrayZDef_single(func, T, ZT, setz)      \\\n"
  "T* func(const mxArray* a, const char** e)     \\\n"
  "{ \\\n"
  "    T* array; \\\n"
  "    mwSize arraylen; \\\n"
  "    mwIndex i; \\\n"
  "    T* p; \\\n"
  "    float* q; \\\n"
  "    mxComplexSingle* z; \\\n"
  "    if (!a || mxGetClassID(a) != mxSINGLE_CLASS) { \\\n"
  "        *e = \"Invalid array argument, mxSINGLE_CLASS expected\"; \\\n"
  "        return 0; \\\n"
  "    } \\\n"
  "    arraylen = mxGetM(a)*mxGetN(a); \\\n"
  "    array = (T*) mxMalloc(mxGetM(a)*mxGetN(a) * sizeof(T)); \\\n"
  "    p = array; \\\n"
  "    if( mxIsComplex(a) ) \\\n"
  "      { \\\n"
  "	z = mxGetComplexSingles(a);	   \\\n"
  "	for (i = 0; i < arraylen; ++i) {	\\\n"
  "	  setz(p, (ZT) (*z).real, (ZT) (*z).imag);	\\\n"
  "  	  ++p; ++z; }					\\\n"
  "      } \\\n"
  "    else \\\n"
  "      {				   \\\n"
  "	q = mxGetSingles(a);	   \\\n"
  "	for (i = 0; i < arraylen; ++i)	{	\\\n"
  "	  setz(p, (ZT) (*q), (ZT) 0 );		\\\n"
  "          ++p; ++q; }			\\\n"
  "      }						\\\n"
  "    return array; \\\n"
  "}\n"
  "\n"
  "\n"
  "#define mxWrapCopyZDef_single(func, T, freal, fimag)	    \\\n"
  "void func(mxArray* a, const T* q, mwSize n) \\\n"
  "{ \\\n"
  "    mwIndex i; \\\n"
  "    float* p;	\\\n"
  "    mxComplexSingle* z; \\\n"
  "    if( mxIsComplex(a) ) \\\n"
  "      { \\\n"
  "	z = mxGetComplexSingles(a);	   \\\n"
  "	for (i = 0; i < n; ++i)	{		\\\n"
  "          (*z).real = freal(*q);			\\\n"
  "	  (*z).imag = fimag(*q);			\\\n"
  "	  ++z; ++q; 	}			\\\n"
  "      } \\\n"
  "    else \\\n"
  "      {				   \\\n"
  "	p = mxGetSingles(a);	   \\\n"
  "	for (i = 0; i < n; ++i)		\\\n"
  "	  *p++ = freal(*q++);		\\\n"
  "      } \\\n"
  "}\n"
  "\n"
  "\n"
  "#define mxWrapReturnZDef_single(func, T, freal, fimag)	      \\\n"
  "mxArray* func(const T* q, mwSize m, mwSize n) \\\n"
  "{ \\\n"
  "    mwIndex i; \\\n"
  "    mxComplexSingle* p; \\\n"
  "    if (!q) { \\\n"
  "        return mxCreateNumericMatrix(0,0, mxSINGLE_CLASS, mxCOMPLEX); \\\n"
  "    } else { \\\n"
  "        mxArray* a = mxCreateNumericMatrix(m,n, mxSINGLE_CLASS, mxCOMPLEX); \\\n"
  "        p = mxGetComplexSingles(a); \\\n"
  "        for (i = 0; i < m*n; ++i) {	  \\\n"
  "          (*p).real = freal(*q);			\\\n"
  "	  (*p).imag = fimag(*q);			\\\n"
  "	  ++p; ++q; 	}			\\\n"
  "        return a; \\\n"
  "    } \\\n"
  "}\n"
  "\n"
  "\n"
  "\n"
  "#else\n"
  "\n"
  "/*\n"
  " * Support routines for copying data into and out of the MEX stubs, -R2017b\n"
  " */\n"
  "\n"
  "void* mxWrapGetP(const mxArray* a, const char* fmt, const char** e)\n"
  "{\n"
  "    void* p = 0;\n"
  "#ifdef R2008OO\n"
  "    mxArray* ap;\n"
  "#endif\n"
  "    if (mxGetClassID(a) == mxDOUBLE_CLASS && \n"
  "        mxGetM(a)*mxGetN(a) == 1 && *mxGetPr(a) == 0)\n"
  "        return p;\n"
  "    if (mxIsChar(a)) {\n"
  "        char pbuf[128];\n"
  "        mxGetString(a, pbuf, sizeof(pbuf));\n"
  "        sscanf(pbuf, fmt, &p);\n"
  "    } \n"
  "#ifdef R2008OO\n"
  "    else if (ap = mxGetProperty(a, 0, \"mwptr\")) {\n"
  "        return mxWrapGetP(ap, fmt, e);\n"
  "    }\n"
  "#endif\n"
  "    if (p == 0)\n"
  "        *e = \"Invalid pointer\";\n"
  "    return p;\n"
  "}\n"
  "\n"
  "mxArray* mxWrapCreateP(void* p, const char* fmt)\n"
  "{\n"
  "    if (p == 0) {\n"
  "        mxArray* z = mxCreateDoubleMatrix(1,1, mxREAL);\n"
  "        *mxGetPr(z) = 0;\n"
  "        return z;\n"
  "    } else {\n"
  "        char pbuf[128];\n"
  "        sprintf(pbuf, fmt, p);\n"
  "        return mxCreateString(pbuf);\n"
  "    }\n"
  "}\n"
  "\n"
  "mxArray* mxWrapStrncpy(const char* s)\n"
  "{\n"
  "    if (s) {\n"
  "        return mxCreateString(s);\n"
  "    } else {\n"
  "        mxArray* z = mxCreateDoubleMatrix(1,1, mxREAL);\n"
  "        *mxGetPr(z) = 0;\n"
  "        return z;\n"
  "    }\n"
  "}\n"
  "\n"
  "double mxWrapGetScalar(const mxArray* a, const char** e)\n"
  "{\n"
  "    if (!a || mxGetClassID(a) != mxDOUBLE_CLASS || mxGetM(a)*mxGetN(a) != 1) {\n"
  "        *e = \"Invalid scalar argument\";\n"
  "        return 0;\n"
  "    }\n"
  "    return *mxGetPr(a);\n"
  "}\n"
  "\n"
  "char* mxWrapGetString(const mxArray* a, const char** e)\n"
  "{\n"
  "    char* s;\n"
  "    mwSize slen;\n"
  "    if (!a || (!mxIsChar(a) && mxGetM(a)*mxGetN(a) > 0)) {\n"
  "        *e = \"Invalid string argument\";\n"
  "        return NULL;\n"
  "    }\n"
  "    slen = mxGetM(a)*mxGetN(a) + 1;\n"
  "    s = (char*) mxMalloc(slen);\n"
  "    if (mxGetM(a)*mxGetN(a) == 0)\n"
  "        *s = 0;\n"
  "    else\n"
  "        mxGetString(a, s, slen);\n"
  "    return s;\n"
  "}\n"
  "\n"
  "\n"
  "#define mxWrapGetArrayDef(func, T) \\\n"
  "T* func(const mxArray* a, const char** e)     \\\n"
  "{ \\\n"
  "    T* array; \\\n"
  "    mwSize arraylen; \\\n"
  "    mwIndex i; \\\n"
  "    T* p; \\\n"
  "    double* q; \\\n"
  "    if (!a || mxGetClassID(a) != mxDOUBLE_CLASS) { \\\n"
  "        *e = \"Invalid array argument, mxDOUBLE_CLASS expected\"; \\\n"
  "        return 0; \\\n"
  "    } \\\n"
  "    arraylen = mxGetM(a)*mxGetN(a); \\\n"
  "    array = (T*) mxMalloc(mxGetM(a)*mxGetN(a) * sizeof(T)); \\\n"
  "    p = array; \\\n"
  "    q = mxGetPr(a); \\\n"
  "    for (i = 0; i < arraylen; ++i) \\\n"
  "        *p++ = (T) (*q++); \\\n"
  "    return array; \\\n"
  "}\n"
  "\n"
  "\n"
  "#define mxWrapCopyDef(func, T) \\\n"
  "void func(mxArray* a, const T* q, mwSize n) \\\n"
  "{ \\\n"
  "    mwIndex i; \\\n"
  "    double* p = mxGetPr(a); \\\n"
  "    for (i = 0; i < n; ++i) \\\n"
  "        *p++ = *q++; \\\n"
  "}\n"
  "\n"
  "\n"
  "#define mxWrapReturnDef(func, T) \\\n"
  "mxArray* func(const T* q, mwSize m, mwSize n) \\\n"
  "{ \\\n"
  "    mwIndex i; \\\n"
  "    double* p; \\\n"
  "    if (!q) { \\\n"
  "        return mxCreateDoubleMatrix(0,0, mxREAL); \\\n"
  "    } else { \\\n"
  "        mxArray* a = mxCreateDoubleMatrix(m,n, mxREAL); \\\n"
  "        p = mxGetPr(a); \\\n"
  "        for (i = 0; i < m*n; ++i) \\\n"
  "            *p++ = *q++; \\\n"
  "        return a; \\\n"
  "    } \\\n"
  "}\n"
  "\n"
  "\n"
  "#define mxWrapGetScalarZDef(func, T, ZT, setz) \\\n"
  "void func(T* z, const mxArray* a) \\\n"
  "{ \\\n"
  "    double* pr = mxGetPr(a); \\\n"
  "    double* pi = mxGetPi(a); \\\n"
  "    setz(z, (ZT) *pr, (pi ? (ZT) *pi : (ZT) 0)); \\\n"
  "}\n"
  "\n"
  "\n"
  "#define mxWrapGetArrayZDef(func, T, ZT, setz) \\\n"
  "T* func(const mxArray* a, const char** e) \\\n"
  "{ \\\n"
  "    T* array; \\\n"
  "    mwSize arraylen; \\\n"
  "    mwIndex i; \\\n"
  "    T* p; \\\n"
  "    double* qr; \\\n"
  "    double* qi; \\\n"
  "    if (!a || mxGetClassID(a) != mxDOUBLE_CLASS) { \\\n"
  "        *e = \"Invalid array argument, mxDOUBLE_CLASS expected\"; \\\n"
  "        return 0; \\\n"
  "    } \\\n"
  "    arraylen = mxGetM(a)*mxGetN(a); \\\n"
  "    array = (T*) mxMalloc(mxGetM(a)*mxGetN(a) * sizeof(T)); \\\n"
  "    p = array; \\\n"
  "    qr = mxGetPr(a); \\\n"
  "    qi = mxGetPi(a); \\\n"
  "    for (i = 0; i < arraylen; ++i) { \\\n"
  "        ZT val_qr = *qr++; \\\n"
  "        ZT val_qi = (qi ? (ZT) *qi++ : (ZT) 0); \\\n"
  "        setz(p, val_qr, val_qi); \\\n"
  "        ++p; \\\n"
  "    } \\\n"
  "    return array; \\\n"
  "}\n"
  "\n"
  "\n"
  "#define mxWrapCopyZDef(func, T, real, imag) \\\n"
  "void func(mxArray* a, const T* q, mwSize n) \\\n"
  "{ \\\n"
  "    mwIndex i; \\\n"
  "    double* pr = mxGetPr(a); \\\n"
  "    double* pi = mxGetPi(a); \\\n"
  "    for (i = 0; i < n; ++i) { \\\n"
  "        *pr++ = real(*q); \\\n"
  "        *pi++ = imag(*q); \\\n"
  "        ++q; \\\n"
  "    } \\\n"
  "}\n"
  "\n"
  "\n"
  "#define mxWrapReturnZDef(func, T, real, imag) \\\n"
  "mxArray* func(const T* q, mwSize m, mwSize n) \\\n"
  "{ \\\n"
  "    mwIndex i; \\\n"
  "    double* pr; \\\n"
  "    double* pi; \\\n"
  "    if (!q) { \\\n"
  "        return mxCreateDoubleMatrix(0,0, mxCOMPLEX); \\\n"
  "    } else { \\\n"
  "        mxArray* a = mxCreateDoubleMatrix(m,n, mxCOMPLEX); \\\n"
  "        pr = mxGetPr(a); \\\n"
  "        pi = mxGetPi(a); \\\n"
  "        for (i = 0; i < m*n; ++i) { \\\n"
  "            *pr++ = real(*q); \\\n"
  "            *pi++ = imag(*q); \\\n"
  "            ++q; \\\n"
  "        } \\\n"
  "        return a; \\\n"
  "    } \\\n"
  "}\n"
  "\n"
  "\n"
  "\n"
  "\n"
  "\n"
  "\n"
  "void* mxWrapGetP_single(const mxArray* a, const char* fmt, const char** e)\n"
  "{\n"
  "    void* p = 0;\n"
  "#ifdef R2008OO\n"
  "    mxArray* ap;\n"
  "#endif\n"
  "    if (mxGetClassID(a) == mxSINGLE_CLASS && \n"
  "        mxGetM(a)*mxGetN(a) == 1 && *((float*)mxGetData(a)) == 0)\n"
  "        return p;\n"
  "    if (mxIsChar(a)) {\n"
  "        char pbuf[128];\n"
  "        mxGetString(a, pbuf, sizeof(pbuf));\n"
  "        sscanf(pbuf, fmt, &p);\n"
  "    } \n"
  "#ifdef R2008OO\n"
  "    else if (ap = mxGetProperty(a, 0, \"mwptr\")) {\n"
  "        return mxWrapGetP(ap, fmt, e);\n"
  "    }\n"
  "#endif\n"
  "    if (p == 0)\n"
  "        *e = \"Invalid pointer\";\n"
  "    return p;\n"
  "}\n"
  "\n"
  "mxArray* mxWrapCreateP_single(void* p, const char* fmt)\n"
  "{\n"
  "    if (p == 0) {\n"
  "        mxArray* z = mxCreateNumericMatrix(1,1, mxSINGLE_CLASS, mxREAL);\n"
  "        *((float*)mxGetData(z)) = 0;\n"
  "        return z;\n"
  "    } else {\n"
  "        char pbuf[128];\n"
  "        sprintf(pbuf, fmt, p);\n"
  "        return mxCreateString(pbuf);\n"
  "    }\n"
  "}\n"
  "mxArray* mxWrapStrncpy_single(const char* s)\n"
  "{\n"
  "    if (s) {\n"
  "        return mxCreateString(s);\n"
  "    } else {\n"
  "        mxArray* z = mxCreateNumericMatrix(1,1, mxSINGLE_CLASS, mxREAL);\n"
  "        *((float*)mxGetData(z)) = 0;\n"
  "        return z;\n"
  "    }\n"
  "}\n"
  "\n"
  "float mxWrapGetScalar_single(const mxArray* a, const char** e)\n"
  "{\n"
  "    if (!a || mxGetClassID(a) != mxSINGLE_CLASS || mxGetM(a)*mxGetN(a) != 1) {\n"
  "        *e = \"Invalid scalar argument\";\n"
  "        return 0;\n"
  "    }\n"
  "    return *((float*)mxGetData(a));\n"
  "}\n"
  "\n"
  "char* mxWrapGetString_single(const mxArray* a, const char** e)\n"
  "{\n"
  "    char* s;\n"
  "    mwSize slen;\n"
  "    if (!a || (!mxIsChar(a) && mxGetM(a)*mxGetN(a) > 0)) {\n"
  "        *e = \"Invalid string argument, mxSINGLE_CLASS expected\";\n"
  "        return NULL;\n"
  "    }\n"
  "    slen = mxGetM(a)*mxGetN(a) + 1;\n"
  "    s = (char*) mxMalloc(slen);\n"
  "    if (mxGetM(a)*mxGetN(a) == 0)\n"
  "        *s = 0;\n"
  "    else\n"
  "        mxGetString(a, s, slen);\n"
  "    return s;\n"
  "}\n"
  "\n"
  "\n"
  "#define mxWrapGetArrayDef_single(func, T) \\\n"
  "T* func(const mxArray* a, const char** e)     \\\n"
  "{ \\\n"
  "    T* array; \\\n"
  "    mwSize arraylen; \\\n"
  "    mwIndex i; \\\n"
  "    T* p; \\\n"
  "    float* q; \\\n"
  "    if (!a || mxGetClassID(a) != mxSINGLE_CLASS) { \\\n"
  "        *e = \"Invalid array argument, mxSINGLE_CLASS expected\"; \\\n"
  "        return 0; \\\n"
  "    } \\\n"
  "    arraylen = mxGetM(a)*mxGetN(a); \\\n"
  "    array = (T*) mxMalloc(mxGetM(a)*mxGetN(a) * sizeof(T)); \\\n"
  "    p = array; \\\n"
  "    q = (float*) mxGetData(a);	   \\\n"
  "    for (i = 0; i < arraylen; ++i) \\\n"
  "        *p++ = (T) (*q++); \\\n"
  "    return array; \\\n"
  "}\n"
  "\n"
  "\n"
  "#define mxWrapCopyDef_single(func, T) \\\n"
  "void func(mxArray* a, const T* q, mwSize n) \\\n"
  "{ \\\n"
  "    mwIndex i; \\\n"
  "    float* p = (float*) mxGetData(a);		\\\n"
  "    for (i = 0; i < n; ++i) \\\n"
  "        *p++ = *q++; \\\n"
  "}\n"
  "\n"
  "\n"
  "#define mxWrapReturnDef_single(func, T) \\\n"
  "mxArray* func(const T* q, mwSize m, mwSize n) \\\n"
  "{ \\\n"
  "    mwIndex i; \\\n"
  "    float* p; \\\n"
  "    if (!q) { \\\n"
  "      return mxCreateNumericMatrix(0,0, mxSINGLE_CLASS, mxREAL); \\\n"
  "    } else { \\\n"
  "        mxArray* a = mxCreateNumericMatrix(m,n, mxSINGLE_CLASS, mxREAL);\\\n"
  "        p = (float*) mxGetData(a);				\\\n"
  "        for (i = 0; i < m*n; ++i) \\\n"
  "            *p++ = *q++; \\\n"
  "        return a; \\\n"
  "    } \\\n"
  "}\n"
  "\n"
  "\n"
  "#define mxWrapGetScalarZDef_single(func, T, ZT, setz) \\\n"
  "void func(T* z, const mxArray* a) \\\n"
  "{ \\\n"
  "    float* pr = (float*) mxGetData(a);		\\\n"
  "    float* pi = (float*) mxGetImagData(a);		 \\\n"
  "    setz(z, (ZT) *pr, (pi ? (ZT) *pi : (ZT) 0)); \\\n"
  "}\n"
  "\n"
  "\n"
  "#define mxWrapGetArrayZDef_single(func, T, ZT, setz) \\\n"
  "T* func(const mxArray* a, const char** e) \\\n"
  "{ \\\n"
  "    T* array; \\\n"
  "    mwSize arraylen; \\\n"
  "    mwIndex i; \\\n"
  "    T* p; \\\n"
  "    float* qr; \\\n"
  "    float* qi; \\\n"
  "    if (!a || mxGetClassID(a) != mxSINGLE_CLASS) { \\\n"
  "        *e = \"Invalid array argument, mxSINGLE_CLASS expected\"; \\\n"
  "        return 0; \\\n"
  "    } \\\n"
  "    arraylen = mxGetM(a)*mxGetN(a); \\\n"
  "    array = (T*) mxMalloc(mxGetM(a)*mxGetN(a) * sizeof(T)); \\\n"
  "    p = array; \\\n"
  "    qr = (float*) mxGetData(a);			\\\n"
  "    qi = (float*) mxGetImagData(a);			\\\n"
  "    for (i = 0; i < arraylen; ++i) { \\\n"
  "        ZT val_qr = *qr++; \\\n"
  "        ZT val_qi = (qi ? (ZT) *qi++ : (ZT) 0); \\\n"
  "        setz(p, val_qr, val_qi); \\\n"
  "        ++p; \\\n"
  "    } \\\n"
  "    return array; \\\n"
  "}\n"
  "\n"
  "\n"
  "#define mxWrapCopyZDef_single(func, T, real, imag) \\\n"
  "void func(mxArray* a, const T* q, mwSize n) \\\n"
  "{ \\\n"
  "    mwIndex i; \\\n"
  "    float* pr = (float*) mxGetData(a);		\\\n"
  "    float* pi = (float*) mxGetImagData(a);		\\\n"
  "    for (i = 0; i < n; ++i) { \\\n"
  "        *pr++ = real(*q); \\\n"
  "        *pi++ = imag(*q); \\\n"
  "        ++q; \\\n"
  "    } \\\n"
  "}\n"
  "\n"
  "\n"
  "#define mxWrapReturnZDef_single(func, T, real, imag) \\\n"
  "mxArray* func(const T* q, mwSize m, mwSize n) \\\n"
  "{ \\\n"
  "    mwIndex i; \\\n"
  "    float* pr; \\\n"
  "    float* pi; \\\n"
  "    if (!q) { \\\n"
  "      return mxCreateNumericMatrix(0,0, mxSINGLE_CLASS, mxCOMPLEX); \\\n"
  "    } else { \\\n"
  "        mxArray* a = mxCreateNumericMatrix(m,n, mxSINGLE_CLASS, mxCOMPLEX);\\\n"
  "        pr = (float*) mxGetData(a);					\\\n"
  "        pi = (float*) mxGetImagData(a);					\\\n"
  "        for (i = 0; i < m*n; ++i) { \\\n"
  "            *pr++ = real(*q); \\\n"
  "            *pi++ = imag(*q); \\\n"
  "            ++q; \\\n"
  "        } \\\n"
  "        return a; \\\n"
  "    } \\\n"
  "}\n"
  "\n"
  "\n"
  "\n"
  "\n"
  "\n"
  "#endif\n";

